import fs from 'node:fs/promises';
import path from 'node:path';
import { exactSlugSegment } from "./dynamic-routes/exact-slug-segment.mjs";
import { catchAllSegment } from "./dynamic-routes/catch-all-segment.mjs";
import { optionalCatchAllSegment } from "./dynamic-routes/optional-catch-all-segment.mjs";
import { RouteHandler } from "./route-handler/route-handler.mjs";
import { MiddlewareHandler } from "./route-handler/middleware-handler.mjs";
import { isCommonJs } from "../utils/env.utils.mjs";
import { validateFileFormat } from "../validations/validations.mjs";
export class FileRouteResolver {
  static fileExtensions = ['js', 'mjs', 'cjs', 'ts'].join('|');
  static fileExtensionPattern = new RegExp(`\\.(${FileRouteResolver.fileExtensions})$`);
  static middlewareFilePattern = new RegExp(`middleware\\.(${FileRouteResolver.fileExtensions})$`);
  // Matches: index.js and index.[get].js
  static indexFilePattern = new RegExp(`index(\\.\\[[^\\]]+\\])?\\.(${FileRouteResolver.fileExtensions})$`);
  clearImportCache = false;
  constructor(data) {
    this.baseDir = data.baseDir;
    this.ignoreFilesRegex = data.ignoreFilesRegex || [];
    if (data.clearImportCache && !isCommonJs()) {
      console.warn('Cache clearing is only supported for CommonJS modules');
    } else {
      this.clearImportCache = data.clearImportCache;
    }
  }
  async getHandlers(directory = this.baseDir) {
    const [middlewares, routes] = await this.scanDirectory(directory);
    return [middlewares.sort((left, right) => left.nestingLevel - right.nestingLevel), routes.sort(this.compareByNestingLevelAndType)];
  }
  async scanDirectory(directory = this.baseDir, parentRoute = '', nestingLevel = 0) {
    const entries = await fs.readdir(directory, {
      withFileTypes: true
    });
    const routeHandlers = [];
    const middlewareHandlers = [];
    for (const entry of entries) {
      const [middlewares, routes] = await this.processEntry(directory, parentRoute, nestingLevel, entry);
      routeHandlers.push(...routes);
      middlewareHandlers.push(...middlewares);
    }
    return [middlewareHandlers, routeHandlers];
  }
  async processEntry(directory, parentRoute, nestingLevel, entry) {
    const routeHandlers = [];
    const middlewareHandlers = [];
    const fullPath = path.join(directory, entry.name);
    const routePath = `${parentRoute}/${entry.name}`;
    if (entry.isDirectory()) {
      const [childMiddlewareHandlers, childHandlers] = await this.scanDirectory(fullPath, routePath, nestingLevel + 1);
      routeHandlers.push(...childHandlers);
      middlewareHandlers.push(...childMiddlewareHandlers);
    } else if (entry.isFile() && this.isValidFile(entry.name)) {
      if (FileRouteResolver.middlewareFilePattern.test(entry.name)) {
        const middlewareHandler = await this.processMiddlewareEntry(fullPath, routePath, nestingLevel);
        middlewareHandlers.push(middlewareHandler);
      } else {
        const routeHandler = await this.processFileEntry(fullPath, entry, routePath, nestingLevel);
        routeHandlers.push(routeHandler);
      }
    }
    return [middlewareHandlers, routeHandlers];
  }
  isValidFile(name) {
    if (this.ignoreFilesRegex.some(pattern => pattern.test(name))) {
      return false;
    }
    return FileRouteResolver.fileExtensionPattern.test(name);
  }
  compareByNestingLevelAndType(left, right) {
    if (left.nestingLevel !== right.nestingLevel) {
      return right.nestingLevel - left.nestingLevel;
    }
    const isDynamic = [optionalCatchAllSegment, catchAllSegment, exactSlugSegment].some(dynamicRoute => dynamicRoute.isMatch(left.fileName));
    return isDynamic ? 1 : -1;
  }
  async processMiddlewareEntry(fullPath, filePath, nestingLevel) {
    if (this.clearImportCache) {
      delete require.cache[fullPath];
    }
    const handler = await import(fullPath).then(module => validateFileFormat(fullPath, module)).then(module => module.default);
    const routePath = filePath.replace(FileRouteResolver.middlewareFilePattern, '');
    return new MiddlewareHandler({
      path: routePath,
      handler,
      nestingLevel
    });
  }
  async processFileEntry(fullPath, entry, routePath, nestingLevel) {
    if (this.clearImportCache) {
      delete require.cache[fullPath];
    }
    const handler = await import(fullPath).then(module => validateFileFormat(fullPath, module)).then(module => module.default);
    const initialRoute = routePath.replace(FileRouteResolver.fileExtensionPattern, '');
    const [method, pureRouteName] = this.extractMethodFromRoute(initialRoute);
    const {
      route,
      paramExtractors
    } = this.parseDynamicParams(pureRouteName);
    const isIndex = FileRouteResolver.indexFilePattern.test(entry.name);
    const routeKey = isIndex ? route.replace(/\/index$/, '') : route;
    const regex = new RegExp(`^${routeKey}/?$`);
    return new RouteHandler({
      method,
      fileName: entry.name,
      handler,
      regex,
      nestingLevel,
      paramExtractors
    });
  }
  parseDynamicParams(initialRoute) {
    return [exactSlugSegment, catchAllSegment, optionalCatchAllSegment].filter(dynamicRoute => dynamicRoute.isMatch(initialRoute)).reduce((acc, route) => {
      const parsedRoute = route.parse(acc.route);
      return {
        route: parsedRoute.route,
        paramExtractors: {
          ...acc.paramExtractors,
          ...parsedRoute.paramExtractors
        }
      };
    }, {
      route: initialRoute,
      paramExtractors: {}
    });
  }
  extractMethodFromRoute(route) {
    const pattern = /\.\[([^\]]+)\](\..+)?$/;
    const match = route.match(pattern);
    if (!match) {
      return [undefined, route];
    }
    const [, method] = match;
    const pureRoute = route.replace(pattern, '');
    return [method, pureRoute];
  }
}
//# sourceMappingURL=file-route-resolver.mjs.map